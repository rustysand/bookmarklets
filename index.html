<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rusty's bookmarks</title>
</head>
<body>
    
    <p>contact the author: Rusty Sand (rustysan) tsunami.numerate576@8alias.com</p>
    <h3><i>On this page I provide a collection of tools in the form of "bookmarklets".
        They are like links that you save to your bookmarks/favorites,
        but unlike ordinary bookmarks that take you to some website,
        when you click on these in your bookmarks,
        it executes a small program on whatever page you happen to have open at the time.
        If you aren't familiar with all this,
        you can learn by first following the steps below to sort foresight by lane number.
        That sould give you a feel for how bookmarklets work, after which you will be
        more prepared to use the more complex tools that follow.
    </i></h3>
    
    <h1>Steps to start sorting foresight by lane number</h1>
    <p>
        First, it helps to have the bookmarks bar visible in your browser.
        <a href="https://help.usepastel.com/en/articles/3380923-how-to-turn-on-your-bookmarks-toolbar">here's a guide for various browsers if you don't know how</a>
    </p>
    <p>After the bookmarks bar is visible, you can drag the link below into your bookmarks bar.
        After that, whenever you have foresight open,
        you only need to click the bookmark once to activate a program that will keep the recommendations sorted by lane number,
        even after the data refreshes automatically.
        If the entire page refreshes, then you will just need to click the bookmark again to reactivate the sorting program.</p>
    
    <a id="sorter-link" href="#">Sort By Lane</a>
    <p>Note that clicking the link on this page will not work.
        The link has to be added to your bookmarks,
        and you must be on the foresight tab when you then click the bookmark.</p>
    <p>After you get this sorting bookmark working, feel free to move on to the other tools below.</p>
    <h1>Tools for capturing recommendation completion status</h1>
    <h3><i>these tools make it easier to submit to the slack channel.
        This is a collection of bookmarklets that allow the needed data to be copied to the clipboard or automatically saved and retrieved later.
        Some of these bookmarks have rather long names that might not fit on your bookmarks bar nicely.
       After you add them to your bookmarks, feel free to edit the names, but changing the url/code will likely make the bookmarklet not function properly</i></h3>
    <p>Drag the following link to your bookmarks bar. When the bookmark is clicked,
    it copies a clear image of the table from foresight,
    kinda like taking a screenshot but better.
    After you click it, it takes a few seconds to capture the image.
    It will look like nothing happened at first, but you will see an alert when the capture completes.</p>
    
    <a id="capture-image-link" href="#">capture image</a><br>
    
    <p>The following copies a summary including completion status and plan id</p>
    <a id="manual-summary-link" href="#">capture summary  </a><br>
    
    
    <p>The following is for capturing the data automatically when timer is close to zero. It will save up to 21 captures in your browser's local storage:</p>
    
    <a id="watcher-link" href="#">Start Autocapture </a><br>

    <p>The following are for retrieving the data that was captured automatically. One retrieves the image, One retrieves the summary.
    When clicked, these bookmarklets will tell you how many captures are available and prompt you to enter a number to select the desired capture.
    Entering 0 selects the most recent capture</p>

    <a id="retrieve-image-link" href="#">retrieve autocaptured image</a><br>
    <a id="retrieve-summary-link" href="#">retrieve autocaptured summary</a><br>

     <p>The following allows you to clear all auto-captures from local storage,
         which might be useful if you want to clean things up after saving the captures to a more permanent storage location.
         Note that the autocapture program also overwrites old captures on a FIFO basis once the number of captures reaches 21</p>
    <a id="clear-captures-link" href="#">clear captures</a><br>
    
  

    <p>Note that for any of the bookmarks that copy things to your clipboard to work, the forsight tab must be open and in focus. Otherwise you will an error like this:</p>
    <img src="focus.png"/>
    <p>But fear not. Simply close the error and click anywhere on the forsight page to make it in focus before clicking the bookmarklet again</p>

    <p>The following are experimental and/or under development:</p>
     <a id="recopy-image-link" href="#">recopy manually captured img</a><br>
    <a id="manual-sajurl-link" href="#">Manually copy Summary+longURL to clipboard</a><br>
    <a id="manual-md-link" href="#">Manually copy Markdown to clipboard</a><br>
    <a id="retriever-json-link" href="#">Retrieve autocaptured JSON  (experimental)</a><br>
    <a id="retriever-md-link" href="#">Retrieve autocaptured Markdown  (experimental)</a><br>
    <a id="download-link" href="#">Manually Download JSON and MD  (experimental)</a><br>
    <a id="manual-saj-link" href="#">Manually copy Summary+JSON to clipboard</a><br>
    <a id="retriever-summaryjson-link" href="#">Retrieve autocaptured summary and JSON  </a><br>
    <a id="retriever-summaryurl-link" href="#">Retrieve autocaptured summary and URL  </a><br>
    

    <script>
        function getTimeLeftElement(){
             const timeDiv = document.querySelector('.sorter-table-header .foresight-table-metadata');
             if (timeDiv)
                 return timeDiv.querySelector('.timer');
             else
                 return null;
        }
        function getTimeLeft(inMS=true) {

           
           const timerSpan = getTimeLeftElement();
            if (!timerSpan) return -1;
            const timeStr = timerSpan.innerText;

            const timeMatch = timeStr.match(/(\d+):(\d+)/);
            if (!timeMatch) return -1;
            if(!inMS) return timeMatch;
            const min = parseInt(timeMatch[1], 10);
            const sec = parseInt(timeMatch[2], 10);
            return (min * 60 + sec) * 1000;
        }

        function formatTime(ms) {
            if (ms < 0) return 'Unknown';
            const totalSec = Math.floor(ms / 1000);
            const min = Math.floor(totalSec / 60);
            const sec = totalSec % 60;
            return `${min}:${sec < 10 ? '0' : ''}${sec}`;
        }


        function getPlanId (){
            const headerDiv = document.querySelector('.sorter-table-header');
            if (!headerDiv) return null;
            const spans = Array.from(headerDiv.querySelectorAll('span'));
            const planIdSpan = spans.find(span => span.innerText.startsWith('Plan Id :'));
            if (!planIdSpan) return null;
            return planIdSpan.innerText;
        }
        
        function captureData(isManual) {
            const table = document.querySelector('.awsui-table-container');
            if (!table) return null;
            const thead = table.querySelector('thead');
            if (!thead) return null;
            const tbody = table.querySelector('tbody');
            if (!tbody) return null;
            const headerRow = thead.rows[0];
            if (!headerRow) return null;
            const headerCells = Array.from(headerRow.cells).map(cell => cell.innerText.trim());
            const bodyRows = Array.from(tbody.rows);
            let completedCount = 0;
            for (const row of bodyRows) {
                const lastCellText = row.cells[row.cells.length - 1].innerText.trim();
                if (lastCellText === 'Completed') {
                    completedCount++;
                }
            }
            const totalCount = bodyRows.length;
            const allCompleted = completedCount === totalCount;
            const status = allCompleted ? 'COMPLETED' : 'INCOMPLETE';
            const planId = getPlanId();
            if (!planId) return null;
            const rowsData = bodyRows.map(row => Array.from(row.cells).map(cell => cell.innerText.trim()));
            const timeLeft = getTimeLeft();
            const timeOfRecommendation = new Date(document.querySelector('.sorter-table-header .foresight-table-metadata small').innerText).toString();
            const timeOfCapture = Date.now();
            const ret =  {
                status,
                planId,
                completedCount,
                totalCount,
                timeOfRecommendation,
                timeOfCapture,
                timeLeft,
                headers: headerCells,
                rows: rowsData
            };
            console.log('Captured:', JSON.stringify(ret).slice(0, 300));
            if(isManual) localStorage.setItem('lastDataCapture', JSON.stringify(ret));
            return ret;
        }
 
        function onTimerTick(timeLeft) {
            console.log('Time left:', formatTime(timeLeft));
            console.log('last updated:', new Date());
            const el = getTimeLeftElement();
            if(el)
            {
                if (el.style.backgroundColor == "blue")
                    el.style.backgroundColor = "#009900";
                else
                    el.style.backgroundColor = "blue";
            }
        }
   

        
        




async function captureImage(isManual) {
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (window.html2canvas) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  async function elementToCanvas(element) {
    return await html2canvas(element, {
      allowTaint: true,
      scale: 1
    });
  }
  const container = document.querySelector('.awsui-table-container');
  if (!container) {
    alert('No .awsui-table-container found');
    return;
  }
  const table = container.querySelector('table');
  if (!table) {
    alert('No table found in .awsui-table-container');
    return;
  }
  const header = document.querySelector('.awsui-table-regions-container');
  await loadScript('https://html2canvas.hertzen.com/dist/html2canvas.min.js');
  const canvas1 = await elementToCanvas(header);
  const canvas2 = await elementToCanvas(table);
  const maxWidth = Math.max(canvas1.width, canvas2.width);
  const totalHeight = canvas1.height + canvas2.height;
  const collageCanvas = document.createElement('canvas');
  collageCanvas.width = maxWidth;
  collageCanvas.height = totalHeight;
  const ctx = collageCanvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, maxWidth, totalHeight);
  const x1 = (maxWidth - canvas1.width) / 2;
  ctx.drawImage(canvas1, x1, 0);
  const x2 = (maxWidth - canvas2.width) / 2;
  ctx.drawImage(canvas2, x2, canvas1.height);
  var ret = collageCanvas.toDataURL('image/png');
  if (isManual) localStorage.setItem('lastImgCapture', ret);
  return ret;
}






        async function captureImageV0() {

            function verticalCollage(dataUrl1, dataUrl2) {
              return new Promise((resolve, reject) => {
                const img1 = new Image();
                img1.src = dataUrl1;
                img1.onload = () => {
                  const img2 = new Image();
                  img2.src = dataUrl2;
                  img2.onload = () => {
                    const maxWidth = Math.max(img1.width, img2.width);
                    const totalHeight = img1.height + img2.height;
                    const canvas = document.createElement('canvas');
                    canvas.width = maxWidth;
                    canvas.height = totalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, maxWidth, totalHeight);
            
                    
                    const x1 = (maxWidth - img1.width) / 2;
                    ctx.drawImage(img1, x1, 0);
            
                    
                    const x2 = (maxWidth - img2.width) / 2;
                    ctx.drawImage(img2, x2, img1.height);
            
                    const collageDataUrl = canvas.toDataURL('image/png');
                    resolve(collageDataUrl);
                  };
                  img2.onerror = reject;
                };
                img1.onerror = reject;
              });
            }


            function loadScript(src) {
                return new Promise((resolve, reject) => {
                  if (window.html2canvas) {
                    resolve();
                    return;
                  }
                  const script = document.createElement('script');
                  script.src = src;
                  script.onload = resolve;
                  script.onerror = reject;
                  document.head.appendChild(script);
                });
            }

            async function tableToPng(tableElement) {
                const canvas = await html2canvas(tableElement, {
                  allowTaint: true,
                  scale: 1
                });
                return canvas.toDataURL('image/png');
            }

          
            const container = document.querySelector('.awsui-table-container');
            if (!container) {
              alert('No .awsui-table-container found');
              return;
            }
            const table = container.querySelector('table');
            if (!table) {
              alert('No table found in .awsui-table-container');
              return;
            }

            const header = document.querySelector('.awsui-table-heading-container');

            await loadScript('https://html2canvas.hertzen.com/dist/html2canvas.min.js');
            const dataUrl1 = await tableToPng(header);
            const dataUrl2 = await tableToPng(table);
            return await verticalCollage(dataUrl1, dataUrl2);
        }
        
        
        function startWatcherMain() {


const tableRefreshDetector_capture = {

        rando: "oisj2389sdfn9"
    ,
        start() {
            this.started = true;
            this.flag = false;
            this.planId = getPlanId();
            this.tbody = getTBody();
            this.firstRow = this.getFirstRow(this.tbody);
            if(this.firstRow)
                this.firstRow[this.rando] = true;
        }
    ,
        flag(){
            this.flag = true;
        }
    ,
        didRefresh() {
            if(!this.started)
                alert("error: attempted to check unstarted detector!");
            const pid = getPlanId();
            const tb = getTBody();
            const fr = this.getFirstRow(tb);
            if( pid !== this.planId || this.tbody !== tb || this.firstRow !== fr )
                return true;
            if (!this.firstRow)
                return false;
            return !fr[this.rando]  || this.flag;
        }
    ,
        getFirstRow(tbody) {
            if (tbody){
                var rows = Array.from(this.tbody.getElementsByTagName('tr'));
                return rows[0];
            }
        }
};

            
            function showAlert(message,ttl=60*60*1000,isError=false) {
              const leftright= isError?"left":"right";
              const bgc = isError?"#900":"#080";
              console.log("sending alert to page with message: "+message);
              const alert = document.createElement('div');
              const closeBtn = document.createElement('span');
              
              alert.textContent = message;
              alert.style.cssText = `
                position: fixed;
                top: 10px;
                ${leftright}: 10px;
                padding: 10px 30px 10px 10px;
                background: ${bgc};
                color: white;
                z-index: 1000;
              `;
              
              closeBtn.textContent = '×';
              closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                cursor: pointer;
              `;
              
              closeBtn.onclick = () => alert.remove();
              window.setTimeout(() => alert.remove(), ttl);
              alert.appendChild(closeBtn);
              document.body.appendChild(alert);
            }
            if (window.watcherActive) {
                const timeLeft = getTimeLeft();
                alert(`Watcher is already active. Time left: ${formatTime(timeLeft)}`);
                return;
            }
            
            window.watcherActive = true;
            const MAX_CAPTURES = 24;
            const CHECK_INTERVAL = 4000;
            const CAPTURE_INTERVAL_SHORT = 15000;
            const CAPTURE_INTERVAL_LONG = 90000;
            const MIN_IMAGE_URL_LENGTH = 1000;
            const alertTTL1 = 10 * 60 * 1000;
            const alertTTL2 = 12 * 60 * 60 * 1000;
            var earliestLikelyRecTime = 3*60*1000;
            var timeChangeTolerance = 1000 * 60 * 4;
            var lastTimeLeft = Number.POSITIVE_INFINITY;
            var lastCaptureTime = 0;
            setInterval(async () => {
                const timeLeft = getTimeLeft();
                onTimerTick(timeLeft);
                if (timeLeft < 0) {
                    return;
                };
    
                if (timeLeft > lastTimeLeft+timeChangeTolerance)
                {
                    console.log(`recommendation refresh detected. (lastTimeLeft,timeLeft): (${lastTimeLeft}, ${timeLeft})` );
                }
                lastTimeLeft = timeLeft;

                async function   justCaptureItFox(rightNow) {
                    let captures = JSON.parse(localStorage.getItem('captures') || '[]');
                    let lastCapture = captures[0];
                    let lastPlanIdCaptured = lastCapture?.data?.planId;
                    console.log("lastPlanIdCaptured: "+lastPlanIdCaptured);

                    tableRefreshDetector_capture.start();
                    const img = await captureImage();
                    const dataObj = captureData();
                    
                    const alertTimeString = new Date(rightNow).toLocaleTimeString('en-US', {hour12: false });
                    const toSave = {data: dataObj, image: img};
                    const samePlan = dataObj?.planId === lastPlanIdCaptured;
                    const saveAbort = () => {
                            let aborts = JSON.parse(localStorage.getItem('aborts') || '[]');
                            aborts.unshift(toSave);
                            localStorage.setItem('aborts', JSON.stringify(aborts));
                    };
                    if(!dataObj) {
                        showAlert(`last capture at ${alertTimeString} aborted. No data object.`,alertTTL2,true);
                        saveAbort();
                    }else if(tableRefreshDetector_capture.didRefresh()) {
                        showAlert(`last capture at ${alertTimeString} aborted due to indication of recommendation refresh.`,alertTTL2);
                        saveAbort();
                    }else if(!dataObj.planId){
                        showAlert(`last capture at ${alertTimeString} aborted because no planId captured`,alertTTL2,true);
                        saveAbort();
                    }else if (img.length<MIN_IMAGE_URL_LENGTH) {
                        showAlert(`capture at ${alertTimeString} aborted. Image too small.`,alertTTL2, true);
                        saveAbort();
                    }else{
                        if (samePlan){
                           captures[0] = toSave;
                        }else{
                            captures.unshift(toSave);
                            if (captures.length > MAX_CAPTURES) captures.pop();
                        }
                        let str = JSON.stringify(captures);
                        localStorage.setItem('captures', str);
                        lastCaptureTime = rightNow;
                        showAlert(`last capture taken at ${alertTimeString} (${dataObj.rows.length},${img.length})`, alertTTL1);
                        
                    }
                }

                const rightNow = Date.now();
                var diff = rightNow-lastCaptureTime;
                if (timeLeft <= CHECK_INTERVAL+earliestLikelyRecTime ) {
                    if(diff>CAPTURE_INTERVAL_SHORT) {
                        await justCaptureItFox(rightNow);
                    }
                } else if (diff>CAPTURE_INTERVAL_LONG) {
                    await justCaptureItFox(rightNow);
                }
            }, CHECK_INTERVAL);
            alert('Watcher started.');
        }
        function clearCaptures (){
            if(prompt("enter 'delete' below to delete all captures")==="delete")
                localStorage.setItem('captures', JSON.stringify([]));
        }
        function retrieveCapture(){
            const captures = JSON.parse(localStorage.getItem('captures') || '[]');
            if (!captures.length) {
                alert('No captures available.');
                return;
            }
            
            const num = parseInt(prompt('How many captures back? Enter 0 for most recent capture. The oldest capture can be retrieved by entering the number '+ (captures.length-1), "0"), 10);
            if (isNaN(num) || num < 0 || num > captures.length-1) {
                alert('Invalid number.');
                return;
            }
            return captures[num];
        }

        
        
        function copyToClipboard(str, name="text"){
            navigator.clipboard.writeText(str).then(() => {
                alert(name+' copied to clipboard!');
            }).catch((e) => {
                alert('Clipboard copy failed: ' + e);
                console.log(e);
            });
        }
  
        function retrieveMarkdownToClipboard() {
            var cap = retrieveCapture();
            if (!cap) return;
            const dataObj = cap.data;
            copyMarkdownFromDataObj(dataObj);
        }

        function retrieveImageToClipboard(){
            var cap = retrieveCapture();
            if (!cap) return;
            copyImage(cap.image);
        }
        
        function summaryFromDataObject(dataObj){
            function formatTimeStamp(t,excludeDate){
                return new Date(t).toLocaleString("en-US", {timeZoneName: "short", hour12: false, year: (excludeDate ? undefined : "numeric"), month: (excludeDate ? undefined : "short"), day: (excludeDate ? undefined : "numeric"), hour: 'numeric', minute: 'numeric'});

            }
            const ret = [
                         [dataObj.planId]
                         ,["time of recommendation : " +formatTimeStamp(dataObj.timeOfRecommendation)]
                         ,["time of capture : " +formatTimeStamp(dataObj.timeOfCapture, true)]
                         ,["time left : " +formatTime( dataObj.timeLeft)]
                         ,[dataObj.status+" " +dataObj.completedCount+"/"+dataObj.totalCount]
                        ];
            return [ret, [ret[0],ret[1],ret[2],ret[3],ret[4]].join("\n")+"\n"];
        }
        
        function buildMarkdownFromDataObject(dataObj){
            let markdown = summaryFromDataObject(dataObj)[1]
            +"===========================\n";

            for (const row of dataObj.rows) {
                if(row.length > 1) {
                    markdown += verticalizedTableRowString(row,dataObj.headers) ;
                    markdown+= "====================\n";
                }
            }
            return markdown;
        }
 
        class FlexIterable {
          constructor(...items) {
            this.items = items.map(item => ({ value: item, processed: false }));
            this.filters = [];
          }

          static from(array) {
            return new FlexIterable(...array);
          }

          addFilter(filterCallback) {
            this.filters.push(filterCallback);
          }

          removeFilter(filterCallback) {
            this.filters = this.filters.filter(f => f !== filterCallback);
          }

          forEachRemaining(actionCallback) {
            for (let i = 0; i < this.items.length; i++) {
              if (!this.items[i].processed) {
                const satisfiesFilters = this.filters.every(filter => filter(this.items[i].value, i));
                if (satisfiesFilters) {
                  const result = actionCallback(this.items[i].value, i);
                  let wasProcessed = false;
                  let stopProcessing = false;

                  if (Array.isArray(result)) {
                    [wasProcessed, stopProcessing] = result;
                  } else {
                    wasProcessed = result;
                  }

                  if (wasProcessed) {
                    this.items[i].processed = true;
                  }

                  if (stopProcessing) {
                    return;
                  }
                }
              }
            }
          }

          reset() {
            this.items.forEach(item => {
              item.processed = false;
            });
          }
        }
        
        function verticalizedTableRowString(row, headers){
            var str = "";
            var headers = FlexIterable.from(headers);
            headers.addFilter(header=>header.indexOf("Assigned?")<0);
            headers.forEachRemaining( (v,i)=>{
                var match = v.match(/([0-9]{2,3}) mins/);
                if (!match){
                    str += v+" : " + row[i] + "\n";
                    return true;
                }
                else{
                    return [false, true];
                }
            });
            var minutesStr="";
            var boxesStr="";
            headers.forEachRemaining( (v,i)=>{
               console.log(v);
                var match = v.match(/([0-9]{2,3}) mins/);
                if (match){
                    minutesStr += (minutesStr?"/ ":"") + match[1];
                    boxesStr += (boxesStr?"/ ":"") + row[i];
                }
                return !!match;
            });
            if (minutesStr){
                str+= minutesStr + " mins : " + boxesStr + " packages\n";
            }
            headers.forEachRemaining( (v,i)=>{
                str += v+" : " + row[i] + "\n";
                return true;
            });
            
            return str;
        }
        function captureMarkdownToClipboard() {
            const dataObj = captureData(true);
            if (!dataObj) {
                alert('Capture failed.');
                return;
            }
            
            copyToClipboard(buildMarkdownFromDataObject(dataObj),"Markdown");
        }

        function copySummaryAndJSONFromDataObj(dataObj,asURL){
            function createURLWithJSON(baseUrl, obj) {
                const jsonStr = encodeURIComponent(JSON.stringify(obj));
                return `${baseUrl}#${jsonStr}`;
            }

            let [tableSummaryRows, slackMsg] = summaryFromDataObject(dataObj);
            const tableData = [...tableSummaryRows,dataObj.headers,...dataObj.rows];
            if(asURL)
                slackMsg+= createURLWithJSON("https://rustysand.github.io/bookmarklets/displayTable.html",tableData);
            else{
                slackMsg+= "https://rustysand.github.io/bookmarklets/displayTable.html\n";
                slackMsg+="```" + JSON.stringify(tableData) + "```";
            }
              
            copyToClipboard(slackMsg,"summary and "+(asURL?"URL":"JSON"));
        }
        
        function captureSummaryAndJSONtoClipboard(asURL) {
            const dataObj = captureData(true);
            if (!dataObj) {
                alert('Capture failed.');
                return;
            }
            copySummaryAndJSONFromDataObj(dataObj,asURL);

        }
        function retrieveSummaryJSONtoClipboard(asURL) {
            var cap = retrieveCapture();
            if (!cap) return;
            const dataObj = cap.data;
            copySummaryAndJSONFromDataObj(dataObj,asURL);
        }
 
        function downloadJsonAndMd() {
            const dataObj = captureData(true);
            if (!dataObj) {
                alert('Capture failed.');
                return;
            }
            const jsonData = JSON.stringify(dataObj, null, 2);
            const blobJson = new Blob([jsonData], { type: 'application/json;charset=utf-8;' });
            const urlJson = URL.createObjectURL(blobJson);
            const linkJson = document.createElement('a');
            linkJson.href = urlJson;
            linkJson.download = 'tasks.json';
            document.body.appendChild(linkJson);
            linkJson.click();
            document.body.removeChild(linkJson);
            URL.revokeObjectURL(urlJson);
            let markdown = buildMarkdownFromDataObject(dataObj);
            const blobMd = new Blob([markdown], { type: 'text/markdown;charset=utf-8;' });
            const urlMd = URL.createObjectURL(blobMd);
            const linkMd = document.createElement('a');
            linkMd.href = urlMd;
            linkMd.download = 'tasks.md';
            document.body.appendChild(linkMd);
            linkMd.click();
            document.body.removeChild(linkMd);
            URL.revokeObjectURL(urlMd);
        }














async function copyImage(dataUrl) {
  const byteString = atob(dataUrl.split(',')[1]);
  const mimeString = dataUrl.split(',')[0].split(':')[1].split(';')[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  const blob = new Blob([ab], { type: mimeString });
  const clipboardItem = new ClipboardItem({ 'image/png': blob });
  await navigator.clipboard.write([clipboardItem]);
  alert('PNG image copied to clipboard! Paste into Slack or other apps.');
}

        

async function captureImageToClipboard() {
var url  = await captureImage(true);

    await copyImage(url);
}



function minimalImageDebugFunction (){
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (window.html2canvas) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  async function minimalTableToPng(tableElement) {
    const canvas = await html2canvas(tableElement, {
      allowTaint: true,
      scale: 1
    });
    return canvas.toDataURL('image/png');
  }
  async function minimalSaveTableImage() {
    const container = document.querySelector('.awsui-table-container');
    if (!container) {
      alert('No .awsui-table-container found');
      return;
    }
    const table = container.querySelector('table');
    if (!table) {
      alert('No table found in .awsui-table-container');
      return;
    }
    try {
      await loadScript('https://html2canvas.hertzen.com/dist/html2canvas.min.js');
      const dataUrl = await minimalTableToPng(table);
      localStorage.setItem('tableImage', dataUrl);
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = 'minimal-table.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.src = dataUrl;
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.zIndex = '9999';
        canvas.style.border = '2px solid green';
        document.body.appendChild(canvas);
        setTimeout(() => {
          document.body.removeChild(canvas);
        }, 5000);
      };
      alert('Minimal debug save complete. Downloaded PNG. Displayed for 5s. Dimensions: ' + img.width + 'x' + img.height);
    } catch (err) {
      alert('Error: ' + err.message);
    }
  }
  minimalSaveTableImage();
}


function imageDebugFunction (){
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (window.html2canvas) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  async function simpleTableToPng(tableElement) {
    console.log('Starting html2canvas render...');
    console.log('Table element:', tableElement);
    console.log('Table outerHTML length:', tableElement.outerHTML.length);
    const canvas = await html2canvas(tableElement, {
      allowTaint: true,
      useCORS: false,
      backgroundColor: null,
      scale: 1,
      logging: true,
      onclone: (clonedDoc, element) => {
        console.log('Clone created, table in clone:', clonedDoc.body.querySelector('table'));
      }
    });
    console.log('Canvas created:', canvas);
    console.log('Canvas dimensions:', canvas.width + 'x' + canvas.height);
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, 1, 1).data;
    console.log('Top-left pixel RGBA:', imageData);
    const dataUrl = canvas.toDataURL('image/png');
    console.log('Data URL length:', dataUrl.length);
    console.log('Data URL preview (first 100 chars):', dataUrl.substring(0, 100));
    return { canvas, dataUrl };
  }
  async function debugSaveTableImage() {
    const container = document.querySelector('.awsui-table-container');
    if (!container) {
      alert('No .awsui-table-container found');
      return;
    }
    const table = container.querySelector('table');
    if (!table) {
      alert('No table found in .awsui-table-container');
      return;
    }
    console.log('Found table, starting debug...');
    try {
      await loadScript('https://html2canvas.hertzen.com/dist/html2canvas.min.js');
      const result = await simpleTableToPng(table);
      localStorage.setItem('tableImage', result.dataUrl);
      
      const a = document.createElement('a');
      a.href = result.dataUrl;
      a.download = 'debug-table.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
     
      result.canvas.style.position = 'fixed';
      result.canvas.style.top = '0';
      result.canvas.style.left = '0';
      result.canvas.style.zIndex = '9999';
      result.canvas.style.border = '2px solid red';
      document.body.appendChild(result.canvas);
      setTimeout(() => {
        document.body.removeChild(result.canvas);
      }, 10000);
      alert('Debug save complete. Downloaded PNG. Check console and on-screen canvas. Data URL length: ' + result.dataUrl.length);
    } catch (err) {
      console.error('Error:', err);
      alert('Error: ' + err.message);
    }
  }
  debugSaveTableImage();
}
        

//refreshes include but are not limited to plan changes. plan change -> table refresh, but not table refresh -> plan change.
//therefore if you detect a plan change, you know a table refresh happened, but if you don't detect a plan change a refresh may still have happened.
class tableRefreshDetector{
        constructor() {
            
          }

        start() {
            
        }

        flag(){

        }
    
        check() {
            
        }
}

const tableRefreshDetector_capture = {

        rando: "oisj2389sdfn9"
    ,
        start() {
            this.started = true;
            this.flag = false;
            this.planId = getPlanId();
            this.tbody = getTBody();
            this.firstRow = this.getFirstRow(this.tbody);
            if(this.firstRow)
                this.firstRow[this.rando] = true;
        }
    ,
        flag(){
            this.flag = true;
        }
    ,
        didRefresh() {
            if(!this.started)
                alert("error: attempted to check unstarted detector!");
            const pid = getPlanId();
            const tb = getTBody();
            const fr = this.getFirstRow(tb);
            if( pid !== this.planId || this.tbody !== tb || this.firstRow !== fr )
                return true;
            if (!this.firstRow)
                return false;
            return !fr[this.rando]  || this.flag;
        }
    ,
        getFirstRow(tbody) {
            if (tbody){
                var rows = Array.from(this.tbody.getElementsByTagName('tr'));
                return rows[0];
            }
        }
};
        

function getTBody (){
    return document.getElementsByClassName('recommendations-table')[0].getElementsByTagName('tbody')[0];
}
        
        function sortByLane() {
            function getChuteAndLaneOfRow(row) {
                const matches = row.getElementsByClassName('proposed-allocation-cell')[0].innerText.match(/FR-[0-9]([0-9]{2})([0-9]{2})/);
                return [parseInt(matches[1]),parseInt(matches[2])];
            }
            function sortRows() {
                var parent = getTBody();
                var rows = Array.from(parent.getElementsByTagName('tr'));
                if (!rows[0].isSortedByLane) {
                    console.log('sorting');
                    for (var i = 0; i < rows.length; i++) {
                        parent.removeChild(rows[i]);
                    }
                    rows = rows.filter(row => row.classList.contains('awsui-table-row'));
                    rows.sort((a, b) =>{
                        chuteLaneA = getChuteAndLaneOfRow(a);
                        chuteLaneB = getChuteAndLaneOfRow(b);
                        if (chuteLaneA[1]-chuteLaneB[1] == 0)
                            return chuteLaneA[0]-chuteLaneB[0];
                        return chuteLaneA[1]-chuteLaneB[1];
                    });
                    for (i = 0; i < rows.length; i++) {
                        parent.appendChild(rows[i]);
                    }
                    rows[0].isSortedByLane = true;
                } else {
                    console.log('already sorted');
                }
            }
            function trySort() {
                try {
                    sortRows();
                } catch (e) {
                    console.log('error when sorting!!!');
                    console.log(e);
                }
                window.setTimeout(trySort, 1000);
            }
            window.setTimeout(trySort, 1000);
        }
        

  function recopyImage(){
      var text  = prompt("0 for image 1 for text");
      if (text==="1"){
        var v=localStorage.getItem('lastDataCapture');
        copyToClipboard(v, "data");
      } else{
          var ur=localStorage.getItem('lastImgCapture');
          if(ur)
            copyImage(ur);
      }
  }
  const recopyCode = [recopyImage, copyToClipboard, copyImage].map(f => f.toString()).join(';') + ';recopyImage();';
  document.getElementById('recopy-image-link').href = 'javascript:(function(){' + recopyCode + '})()';
        
  function retrieveSummaryToClipboard(){
      var cap = retrieveCapture();
      if(cap)
        copyToClipboard(summaryFromDataObject(cap.data)[1], "summary");
  }
  
          const retrieveSummaryCode = [retrieveCapture, copyToClipboard, formatTime, summaryFromDataObject, retrieveSummaryToClipboard].map(f => f.toString()).join(';') + ';retrieveSummaryToClipboard();';
          document.getElementById('retrieve-summary-link').href = 'javascript:(function(){' + retrieveSummaryCode + '})()';
  
        function captureSummaryToClipboard(){
            copyToClipboard(summaryFromDataObject(captureData(true))[1], "summary");
        }
        
        
        const summaryCode = [getPlanId,captureData, copyToClipboard, getTimeLeft, getTimeLeftElement, formatTime, summaryFromDataObject, captureSummaryToClipboard].map(f => f.toString()).join(';') + ';captureSummaryToClipboard();';
        document.getElementById('manual-summary-link').href = 'javascript:(function(){' + summaryCode + '})()';
        

        function retrieveJSONtoClipboard (){
            var cap = retrieveCapture();
            if(cap)
                copyToClipboard(JSON.stringify(retrieveCapture().data),"JSON");
        }
        
        
        const retrieveJSONCode = [copyToClipboard, retrieveCapture,retrieveJSONtoClipboard].map(f => f.toString()).join(';')
        + ';retrieveJSONtoClipboard();';
        document.getElementById('retriever-json-link').href = 'javascript:(function(){' + retrieveJSONCode + '})()';
 
        // Dynamically set the hrefs
        const watcherCode = [getPlanId,getTimeLeft, formatTime, captureData, onTimerTick, startWatcherMain,formatTime,getTimeLeftElement, captureImage].map(f => f.toString()).join(';') + ';startWatcherMain();';
        document.getElementById('watcher-link').href = 'javascript:(function(){' + watcherCode + '})()';


        const retrieveMDCode = [retrieveMarkdownToClipboard, retrieveCapture,buildMarkdownFromDataObject,summaryFromDataObject,copyToClipboard].map(f => f.toString()).join(';') + ';retrieveMarkdownToClipboard();';
        document.getElementById('retriever-md-link').href = 'javascript:(function(){' + retrieveMDCode + '})()';


        
        
        const retrieveSummaryJSONcode = [copyToClipboard, retrieveCapture,copySummaryAndJSONFromDataObj,summaryFromDataObject,retrieveSummaryJSONtoClipboard,formatTime].map(f => f.toString()).join(';')
        + ';retrieveSummaryJSON();';
        document.getElementById('retriever-summaryjson-link').href = 'javascript:(function(){' + retrieveSummaryJSONcode + '})()';


        const retrieveSummaryURLcode = [copyToClipboard, retrieveCapture,copySummaryAndJSONFromDataObj,summaryFromDataObject,retrieveSummaryJSONtoClipboard,formatTime].map(f => f.toString()).join(';')
        + ';retrieveSummaryJSON(true);';
        document.getElementById('retriever-summaryurl-link').href = 'javascript:(function(){' + retrieveSummaryURLcode + '})()';
        

        const manualCode = [getPlanId,captureData, captureMarkdownToClipboard,verticalizedTableRowString,FlexIterable,copyToClipboard,getTimeLeft,getTimeLeftElement,formatTime,buildMarkdownFromDataObject,summaryFromDataObject].map(f => f.toString()).join(';') + ';captureMarkdownToClipboard();';
        document.getElementById('manual-md-link').href = 'javascript:(function(){' + manualCode + '})()';
        
        const manualSummaryAndJSONbaseCode = [copySummaryAndJSONFromDataObj,summaryFromDataObject,getPlanId,captureData, captureSummaryAndJSONtoClipboard, copyToClipboard, getTimeLeft,getTimeLeftElement,formatTime].map(f => f.toString()).join(';');
        
        const manualSummaryAndJSONcode =  manualSummaryAndJSONbaseCode + ';captureSummaryAndJSONtoClipboard();';
        document.getElementById('manual-saj-link').href = 'javascript:(function(){' + manualSummaryAndJSONcode + '})()';
        
        const manualSummaryAndURLcode = manualSummaryAndJSONbaseCode + ';captureSummaryAndJSONtoClipboard(true);';
        document.getElementById('manual-sajurl-link').href = 'javascript:(function(){' + manualSummaryAndURLcode + '})()';
        
        

        const downloadCode = [getPlanId,captureData, downloadJsonAndMd,getTimeLeft,getTimeLeftElement,formatTime].map(f => f.toString()).join(';') + ';downloadJsonAndMd();';
        document.getElementById('download-link').href = 'javascript:(function(){' + downloadCode + '})()';

        const sortCode = [getTBody, sortByLane,getTimeLeft,getTimeLeftElement,formatTime].map(f => f.toString()).join(';') + ';sortByLane();';
        document.getElementById('sorter-link').href = 'javascript:(function(){' + sortCode + '})()';
    
        
        const clearCapturesCode = [clearCaptures].map(f => f.toString()).join(';') + ';clearCaptures();';
        document.getElementById('clear-captures-link').href = 'javascript:(function(){' + clearCapturesCode + '})()';

        
        const captureImageCode = [captureImageToClipboard, copyImage, captureImage].map(f => f.toString()).join(';') + ';captureImageToClipboard();';
        document.getElementById('capture-image-link').href = 'javascript:(function(){' + captureImageCode + '})()';

        const retrieveImageCode = [retrieveImageToClipboard, retrieveCapture, captureImage, copyImage].map(f => f.toString()).join(';') + ';retrieveImageToClipboard();';
        document.getElementById('retrieve-image-link').href = 'javascript:(function(){' + retrieveImageCode + '})()';
        
    </script>
</body>
</html>
