<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rusty's bookmarks</title>
</head>
<body>
    
    <p>contact the author: Rusty Sand (rustysan) tsunami.numerate576@8alias.com</p>
    <h1>Steps to start sorting foresight by lane number</h1>
    <p>First, it helps to have the bookmarks bar visible in your browser. 
        The bookmarks bar is usually a bar under the address bar where you can save links.
        You might already have it set to visible, but if not, it's easy to make it show up, 
        although the process is slightly different for each browser. 
        Google it if you dont know how.</p>
    <p>After the bookmarks bar is visible, you can drag the link below into your bookmarks bar. 
        After that, whenever you have foresight open, 
        you only need to click the bookmark once to activate a program that will keep the recommendations sorted by lane number,
        even after the data refreshes automatically.
        If the entire page refreshes, then you will just need to click the bookmark again to reactive the sorting program.</p>
    <p>Note that clicking the link on this page will not work. 
        The link has to be added to your bookmarks, 
        and you must be on the foresight tab when you then click the bookmark.</p>
    <a id="sorter-link" href="#">Sort By Lane</a>
    <h1>Tools for capturing recommendation completion status</h1>
    <h3><i>these tools make it easier to submit to the slack channel. This is a collection of bookmarklets that allow the needed data to be copied to the clipboard or automatically saved and retrieved later.</i></h3>
    <p>Drag the following link to your bookmarks bar. When the bookmark is clicked, it copies the data from foresight, kinda like taking a screenshot but better.
    Forsight tab must be open and in focus for this to work (click anywhere on the forsight page to make it in focus)</p>
    <a id="manual-saj-link" href="#">Manually copy Summary+JSON to clipboard</a><br>
    
    <p>The following also copy the data to your clip board, but in experimental formats. Try them all and see which you like or just stick to the recommended format above:</p>
    
    <a id="manual-sajurl-link" href="#">Manually copy Summary+longURL to clipboard</a><br>
    <a id="manual-md-link" href="#">Manually copy Markdown to clipboard</a><br>
    
    <p>The following are for capturing the data automatically when timer is close to zero:</p>
    
    <a id="watcher-link" href="#">Start Autocapture </a><br>
    <a id="retriever-summaryjson-link" href="#">Retrieve autocaptured summary and JSON  </a><br>
    <a id="retriever-summaryurl-link" href="#">Retrieve autocaptured summary and URL  </a><br>
    <a id="clear-captures-link" href="#">clear captures</a><br>
    
    <p>The following are experimental and/or under development:</p>
    <a id="retriever-json-link" href="#">Retrieve autocaptured JSON  (experimental)</a><br>
    <a id="retriever-md-link" href="#">Retrieve autocaptured Markdown  (experimental)</a><br>
    <a id="download-link" href="#">Manually Download JSON and MD  (experimental)</a><br>


    <script>
        function getTimeLeftElement(){
             const timeDiv = document.querySelector('.sorter-table-header .foresight-table-metadata');
             if (timeDiv) 
                 return timeDiv.querySelector('.timer');
             else
                 return null;
        }
        function getTimeLeft(inMS=true) {

           
           const timerSpan = getTimeLeftElement();
            if (!timerSpan) return -1;
            const timeStr = timerSpan.innerText;

            const timeMatch = timeStr.match(/(\d+):(\d+)/);
            if (!timeMatch) return -1;
            if(!inMS) return timeMatch;
            const min = parseInt(timeMatch[1], 10);
            const sec = parseInt(timeMatch[2], 10);
            return (min * 60 + sec) * 1000;
        }

        function formatTime(ms) {
            if (ms < 0) return 'Unknown';
            const totalSec = Math.floor(ms / 1000);
            const min = Math.floor(totalSec / 60);
            const sec = totalSec % 60;
            return `${min}:${sec < 10 ? '0' : ''}${sec}`;
        }
   
        function captureData() {
            const table = document.querySelector('.awsui-table-container');
            if (!table) return null;
            const thead = table.querySelector('thead');
            if (!thead) return null;
            const tbody = table.querySelector('tbody');
            if (!tbody) return null;
            const headerRow = thead.rows[0];
            if (!headerRow) return null;
            const headerCells = Array.from(headerRow.cells).map(cell => cell.innerText.trim());
            const bodyRows = Array.from(tbody.rows);
            let completedCount = 0;
            for (const row of bodyRows) {
                const lastCellText = row.cells[row.cells.length - 1].innerText.trim();
                if (lastCellText === 'Completed') {
                    completedCount++;
                }
            }
            const totalCount = bodyRows.length;
            const allCompleted = completedCount === totalCount;
            const status = allCompleted ? 'COMPLETED' : 'INCOMPLETE';
            const headerDiv = document.querySelector('.sorter-table-header');
            if (!headerDiv) return null;
            const spans = Array.from(headerDiv.querySelectorAll('span'));
            const planIdSpan = spans.find(span => span.innerText.startsWith('Plan Id :'));
            if (!planIdSpan) return null;
            const planId = planIdSpan.innerText;
            const rowsData = bodyRows.map(row => Array.from(row.cells).map(cell => cell.innerText.trim()));
            const timeLeft = getTimeLeft();
            const timeOfRecommendation = new Date(document.querySelector('.sorter-table-header .foresight-table-metadata small').innerText).toString();
            const timeOfCapture = new Date().toString();
            return {
                status,
                planId,
                completedCount,
                totalCount,
                timeOfRecommendation,
                timeOfCapture,
                timeLeft,
                headers: headerCells,
                rows: rowsData
            };
        }
 
        function onTimerTick(timeLeft) {
            console.log('Time left:', formatTime(timeLeft));
            console.log('last updated:', new Date());
            const el = getTimeLeftElement();
            if(el)
            {
                if (el.style.backgroundColor == "blue")
                    el.style.backgroundColor = "#009900";
                else
                    el.style.backgroundColor = "blue";
            }
        }
   
        function onCapture(data) {
            console.log('Captured:', data.slice(0, 200));
        }

        function startWatcherMain() {
            function showAlert(message) {
              const alert = document.createElement('div');
              const closeBtn = document.createElement('span');
              
              alert.textContent = message;
              alert.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 10px 30px 10px 10px;
                background: #333;
                color: white;
                z-index: 1000;
              `;
              
              closeBtn.textContent = 'Ã—';
              closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                cursor: pointer;
              `;
              
              closeBtn.onclick = () => alert.remove();
              
              alert.appendChild(closeBtn);
              document.body.appendChild(alert);
            }
            if (window.watcherActive) {
                const timeLeft = getTimeLeft();
                alert(`Watcher is already active. Time left: ${formatTime(timeLeft)}`);
                return;
            }
            window.watcherActive = true;
            const MAX_CAPTURES = 21;
            const CHECK_INTERVAL = 2000;
            var earliestLikelyRecTime = 60*1000;
            var overwriteCapture = false;
            var lastTimeLeft = Number.POSITIVE_INFINITY;
            setInterval(() => {
                const timeLeft = getTimeLeft();
                onTimerTick(timeLeft);
                if (timeLeft < 0) {
                    return;
                };
                if (timeLeft > lastTimeLeft && !overwriteCapture)
                {
                    showAlert("timer reset before any capture was taken. last tick time left: "+ lastTimeLeft);
                }
                lastTimeLeft = timeLeft;
                if (timeLeft <= CHECK_INTERVAL+earliestLikelyRecTime ) {
                    const dataObj = captureData();
                    if (dataObj) {
                        const jsonData = JSON.stringify(dataObj);
                        let captures = JSON.parse(localStorage.getItem('captures') || '[]');
                        if (overwriteCapture){
                           captures[0] = jsonData;
                        }else{
                            captures.unshift(jsonData);
                            if (captures.length > MAX_CAPTURES) captures.pop();
                            overwriteCapture = true;
                        }
                        localStorage.setItem('captures', JSON.stringify(captures));
                        onCapture(jsonData);
                    } else alert("capture fail, no dataObj");
                    
                } else {
                    overwriteCapture = false;
                }
            }, CHECK_INTERVAL);
            alert('Watcher started.');
        }
        function clearCaptures (){
            if(prompt("enter 'delete' below to delete all captures")==="delete")
                localStorage.setItem('captures', JSON.stringify([]));
        }
        function retrieveCapture(){
            const captures = JSON.parse(localStorage.getItem('captures') || '[]');
            if (!captures.length) {
                alert('No captures available.');
                return;
            }
            
            const num = parseInt(prompt('How many captures back? Enter 0 for most recent capture (0-' + (captures.length-1) + '):',"0"), 10);
            if (isNaN(num) || num < 0 || num > captures.length-1) {
                alert('Invalid number.');
                return;
            }
            return captures[num];
        }
        
        function copyToClipBoard(str, name="text"){
            navigator.clipboard.writeText(str).then(() => {
                alert(name+' copied to clipboard!');
            }).catch((e) => {
                alert('Clipboard copy failed. '+name+" : " + str.slice(0, 200));
                console.log(e);
            });
        }
  
        function retrieveMarkdown() {

            const dataObj = JSON.parse(retrieveCapture());
            copyMarkdownFromDataObj(dataObj);
        }
        
        function summaryFromDataObject(dataObj){
            function formatTimeStamp(t,excludeDate){
                return new Date(t).toLocaleString("en-US", {timeZoneName: "short", hour12: false, year: (excludeDate ? undefined : "numeric"), month: (excludeDate ? undefined : "short"), day: (excludeDate ? undefined : "numeric"), hour: 'numeric', minute: 'numeric'});

            }
            const ret = [
                         [dataObj.planId]
                         ,["time of recommendation : " +formatTimeStamp(dataObj.timeOfRecommendation)]
                         ,["time of capture : " +formatTimeStamp(dataObj.timeOfCapture, true)]
                         ,["time left : " +formatTime( dataObj.timeLeft)]
                         ,[dataObj.status+" " +dataObj.completedCount+"/"+dataObj.totalCount]
                        ];
            return [ret, [ret[0],ret[1],ret[2],ret[3],ret[4]].join("\n")+"\n"];
        }
        
        function buildMarkdownFromDataObject(dataObj){
            let markdown = summaryFromDataObject(dataObj)[1]
            +"===========================\n";

            for (const row of dataObj.rows) {
                if(row.length > 1) {
                    markdown += verticalizedTableRowString(row,dataObj.headers) ;
                    markdown+= "====================\n";
                }
            }
            return markdown;
        }
 
        class FlexIterable {
          constructor(...items) {
            this.items = items.map(item => ({ value: item, processed: false }));
            this.filters = [];
          }

          static from(array) {
            return new FlexIterable(...array);
          }

          addFilter(filterCallback) {
            this.filters.push(filterCallback);
          }

          removeFilter(filterCallback) {
            this.filters = this.filters.filter(f => f !== filterCallback);
          }

          forEachRemaining(actionCallback) {
            for (let i = 0; i < this.items.length; i++) {
              if (!this.items[i].processed) {
                const satisfiesFilters = this.filters.every(filter => filter(this.items[i].value, i));
                if (satisfiesFilters) {
                  const result = actionCallback(this.items[i].value, i);
                  let wasProcessed = false;
                  let stopProcessing = false;

                  if (Array.isArray(result)) {
                    [wasProcessed, stopProcessing] = result;
                  } else {
                    wasProcessed = result;
                  }

                  if (wasProcessed) {
                    this.items[i].processed = true;
                  }

                  if (stopProcessing) {
                    return;
                  }
                }
              }
            }
          }

          reset() {
            this.items.forEach(item => {
              item.processed = false;
            });
          }
        }
        
        function verticalizedTableRowString(row, headers){
            var str = "";
            var headers = FlexIterable.from(headers);
            headers.addFilter(header=>header.indexOf("Assigned?")<0);
            headers.forEachRemaining( (v,i)=>{
                var match = v.match(/([0-9]{2,3}) mins/);
                if (!match){
                    str += v+" : " + row[i] + "\n";
                    return true;
                }
                else{
                    return [false, true];
                }
            });    
            var minutesStr="";
            var boxesStr="";
            headers.forEachRemaining( (v,i)=>{
               console.log(v);
                var match = v.match(/([0-9]{2,3}) mins/);
                if (match){
                    minutesStr += (minutesStr?"/ ":"") + match[1];
                    boxesStr += (boxesStr?"/ ":"") + row[i];
                }
                return !!match;
            });
            if (minutesStr){
                str+= minutesStr + " mins : " + boxesStr + " packages\n";
            }
            headers.forEachRemaining( (v,i)=>{
                str += v+" : " + row[i] + "\n";
                return true;
            });
            
            return str;
        }
        function manualMarkdown() {
            const dataObj = captureData();
            if (!dataObj) {
                alert('Capture failed.');
                return;
            }
            
            copyToClipBoard(buildMarkdownFromDataObject(dataObj),"Markdown");
        }

        function summaryAndJSONFromDataObj(dataObj,asURL){
            function createURLWithJSON(baseUrl, obj) {
                const jsonStr = encodeURIComponent(JSON.stringify(obj));
                return `${baseUrl}#${jsonStr}`;
            }

            let [tableSummaryRows, slackMsg] = summaryFromDataObject(dataObj);
            const tableData = [...tableSummaryRows,dataObj.headers,...dataObj.rows];
            if(asURL)
                slackMsg+= createURLWithJSON("https://rustysand.github.io/bookmarklets/displayTable.html",tableData);
            else{
                slackMsg+= "https://rustysand.github.io/bookmarklets/displayTable.html\n";
                slackMsg+="```" + JSON.stringify(tableData) + "```";
            }
              
            copyToClipBoard(slackMsg,"summary and "+(asURL?"URL":"JSON"));
        }
        
        function manualSummaryAndJSON(asURL) {
            const dataObj = captureData();
            if (!dataObj) {
                alert('Capture failed.');
                return;
            }
            summaryAndJSONFromDataObj(dataObj,asURL);

        }
        function retrieveSummaryJSON(asURL) {
            var cap = retrieveCapture();
            if (!cap) return;
            const dataObj = JSON.parse(cap);
            summaryAndJSONFromDataObj(dataObj,asURL);
        }
 
        function downloadJsonAndMd() {
            const dataObj = captureData();
            if (!dataObj) {
                alert('Capture failed.');
                return;
            }
            const jsonData = JSON.stringify(dataObj, null, 2);
            const blobJson = new Blob([jsonData], { type: 'application/json;charset=utf-8;' });
            const urlJson = URL.createObjectURL(blobJson);
            const linkJson = document.createElement('a');
            linkJson.href = urlJson;
            linkJson.download = 'tasks.json';
            document.body.appendChild(linkJson);
            linkJson.click();
            document.body.removeChild(linkJson);
            URL.revokeObjectURL(urlJson);
            let markdown = buildMarkdownFromDataObject(dataObj);
            const blobMd = new Blob([markdown], { type: 'text/markdown;charset=utf-8;' });
            const urlMd = URL.createObjectURL(blobMd);
            const linkMd = document.createElement('a');
            linkMd.href = urlMd;
            linkMd.download = 'tasks.md';
            document.body.appendChild(linkMd);
            linkMd.click();
            document.body.removeChild(linkMd);
            URL.revokeObjectURL(urlMd);
        }
 
        function sortByLane() {
            function getChuteAndLaneOfRow(row) {
                const matches = row.getElementsByClassName('proposed-allocation-cell')[0].innerText.match(/FR-[0-9]([0-9]{2})([0-9]{2})/);
                return [parseInt(matches[1]),parseInt(matches[2])];
            }
            function sortRows() {
                var parent = document.getElementsByClassName('recommendations-table')[0].getElementsByTagName('tbody')[0];
                var rows = Array.from(parent.getElementsByTagName('tr'));
                if (!rows[0].isSortedByLane) {
                    console.log('sorting');
                    for (var i = 0; i < rows.length; i++) {
                        parent.removeChild(rows[i]);
                    }
                    rows = rows.filter(row => row.classList.contains('awsui-table-row'));
                    rows.sort((a, b) =>{
                        chuteLaneA = getChuteAndLaneOfRow(a);
                        chuteLaneB = getChuteAndLaneOfRow(b);
                        if (chuteLaneA[1]-chuteLaneB[1] == 0)
                            return chuteLaneA[0]-chuteLaneB[0];
                        return chuteLaneA[1]-chuteLaneB[1];
                    });
                    for (i = 0; i < rows.length; i++) {
                        parent.appendChild(rows[i]);
                    }
                    rows[0].isSortedByLane = true;
                } else {
                    console.log('already sorted');
                }
            }
            function trySort() {
                try {
                    sortRows();
                } catch (e) {
                    console.log('error when sorting!!!');
                    console.log(e);
                }
                window.setTimeout(trySort, 1000);
            }
            window.setTimeout(trySort, 1000);
        }
 
        // Dynamically set the hrefs
        const watcherCode = [getTimeLeft, formatTime, captureData, onTimerTick, onCapture, startWatcherMain,formatTime,getTimeLeftElement].map(f => f.toString()).join(';') + ';startWatcherMain();';
        document.getElementById('watcher-link').href = 'javascript:(function(){' + watcherCode + '})()';

        const retrieveJSONCode = [copyToClipBoard, retrieveCapture].map(f => f.toString()).join(';')
        + ';var cap = retrieveCapture();if(cap)copyToClipBoard(retrieveCapture(),"JSON");';
        document.getElementById('retriever-json-link').href = 'javascript:(function(){' + retrieveJSONCode + '})()';

        const retrieveMDCode = [retrieveMarkdown, retrieveCapture,buildMarkdownFromDataObject,summaryFromDataObject,copyToClipBoard].map(f => f.toString()).join(';') + ';retrieveMarkdown();';
        document.getElementById('retriever-md-link').href = 'javascript:(function(){' + retrieveMDCode + '})()';
        
        
        const retrieveSummaryJSONCode = [copyToClipBoard, retrieveCapture,summaryAndJSONFromDataObj,summaryFromDataObject,retrieveSummaryJSON,formatTime].map(f => f.toString()).join(';')
        + ';retrieveSummaryJSON();';
        document.getElementById('retriever-summaryjson-link').href = 'javascript:(function(){' + retrieveSummaryJSONCode + '})()';


        const retrieveSummaryURLCode = [copyToClipBoard, retrieveCapture,summaryAndJSONFromDataObj,summaryFromDataObject,retrieveSummaryJSON,formatTime].map(f => f.toString()).join(';')
        + ';retrieveSummaryJSON(true);';
        document.getElementById('retriever-summaryurl-link').href = 'javascript:(function(){' + retrieveSummaryURLCode + '})()';
        

        const manualCode = [captureData, manualMarkdown,verticalizedTableRowString,FlexIterable,copyToClipBoard,getTimeLeft,getTimeLeftElement,formatTime,buildMarkdownFromDataObject,summaryFromDataObject].map(f => f.toString()).join(';') + ';manualMarkdown();';
        document.getElementById('manual-md-link').href = 'javascript:(function(){' + manualCode + '})()';
        
        const manualSummaryAndJSONBaseCode = [summaryAndJSONFromDataObj,summaryFromDataObject,captureData, manualSummaryAndJSON, copyToClipBoard, getTimeLeft,getTimeLeftElement,formatTime].map(f => f.toString()).join(';');
        
        const manualSummaryAndJSONCode =  manualSummaryAndJSONBaseCode + ';manualSummaryAndJSON();';
        document.getElementById('manual-saj-link').href = 'javascript:(function(){' + manualSummaryAndJSONCode + '})()';
        
        const manualSummaryAndURLCode = manualSummaryAndJSONBaseCode + ';manualSummaryAndJSON(true);';
        document.getElementById('manual-sajurl-link').href = 'javascript:(function(){' + manualSummaryAndURLCode + '})()';
        
        

        const downloadCode = [captureData, downloadJsonAndMd,getTimeLeft,getTimeLeftElement,formatTime].map(f => f.toString()).join(';') + ';downloadJsonAndMd();';
        document.getElementById('download-link').href = 'javascript:(function(){' + downloadCode + '})()';
        
        document.getElementById('sorter-link').href = 'javascript:(' + sortByLane.toString() + ')()';
        
        const clearCapturesCode = [clearCaptures].map(f => f.toString()).join(';') + ';clearCaptures();';
        document.getElementById('clear-captures-link').href = 'javascript:(function(){' + clearCapturesCode + '})()';
        
    </script>
</body>
</html>
